#include "planprog2tlv.h"

using namespace std;
using namespace ast;
using namespace pprog;


ostream& PlanProg2TLV::toTLV(ostream& o, const Domain* d, const PlanningProgram* p){
	// o << endl << *d << endl << *p << endl << endl;	
	
	outputHeader(o);
	o << endl; 
	outputMain(o);
	o << endl; 
	outputSystem(d,p,o);
	o << endl; 
	outputEnvironment(d,p,o);
	o << endl; 
	return o;
}


void PlanProg2TLV::outputHeader(ostream& o){
	o << "-- Automatically generated by pp2smv" << endl;
}


void PlanProg2TLV::outputMain(std::ostream& o){
	o << "MODULE main" << endl;	
	o << ind() << "VAR" << endl;
	o << ind(2) << "environment : system environment_module(agent);" << endl;
	o << ind(2) << "agent : system system_module(environment);" << endl;
	o << ind() << "DEFINE" << endl;
	o << ind(2) << "good := agent.last;" << endl;
	o << "-- end of main " << endl;
}

void PlanProg2TLV::outputSystem(const Domain* d, const PlanningProgram* p, std::ostream& o){
	o << "MODULE system_module(env)" << endl << endl;	
	o << ind() << "VAR" << endl;	
	o << ind(2) << "action : {" << endl;
	o << ind(3) << "start_action," << endl;
	outputActionList(d,o, 3);
	o << ind(2) << "};" << endl << endl;
	o << ind(2) << "last : boolean;" << endl << endl;
	
	o << ind() << "INIT" << endl;	
	o << ind(2) << "action = start_action & last = 0" << endl << endl;	
	
	o << ind() << "TRANS" << endl;
	o << ind(2) << "next(action) != start_action &" << endl;
	o << ind(2) << "(next(action) = nop <-> next(last)) &" << endl;
	o << ind(2) << "-- Action preconditions" << endl;
	outputPreconditions(d,o,2);
	o << ind(2) << "&" << endl;
	outputPlanningProgramRequirement(p,o,2);
	o << "-- end of system_module" << endl;
}


void PlanProg2TLV::outputEnvironment(const Domain* d, const PlanningProgram* p, std::ostream& o){
	o << "MODULE environment_module(sys)" << endl << endl;
	o << ind() << "VAR" << endl;
	o << ind(2) << "--domain fluents" << endl;
	outputFluents(d,o,3);
	o << endl;
	o << ind(2) << "--planning program current state" << endl;
	o << ind(3) << "planning_program_state : {" << endl;
	o << ind(4) << "start_state," << endl;
	outputPlanningProgramNodes(p,o,4);
	o << ind(3) << "};" << endl;
	o << endl;
	o << ind(2) << "--pending planning program transition" << endl;
	o << ind(3) << "planning_program_transition : {" << endl;
	o << ind(4) << "start_transition," << endl;
	outputPlanningProgramTransitions(p,o,4);
	o << ind(3) << "};" << endl;
	o << endl;
	o << ind() << "INIT" << endl;
	outputEnvironmentInit(d,p,o,2);
	o << endl;
	o << ind() << "TRANS" << endl;
	outputEnvironmentActions(d,p,o,2);
	o << ind(2) << "&" << endl;
	outputPlanningProgramConstraints(d,p,o,2);
	o << "-- end of environment_module" << endl;
}


void PlanProg2TLV::outputActionList(const Domain* d, std::ostream& o, unsigned int indt){
	vector<const Action*> actions = d->getActions();
	for (unsigned int i = 0; i < actions.size(); i++){
		o << ind(indt) << actions[i]->getName();
		o << ",";
		o << endl;
	}
	o << ind(indt) << "nop" << endl;
}

void PlanProg2TLV::outputPreconditions(const Domain* d, std::ostream& o, unsigned int indt){
	vector<const Action*> actions = d->getActions();
	o << ind(indt) << "case" << endl;
	for (unsigned int i = 0; i < actions.size(); i++){
		if (actions[i] -> getPrecondition() != NULL){
			o << ind(indt+1) << "next(action) = " << actions[i]->getName() << " : " ; 
			outputGDFormula(actions[i] -> getPrecondition(),o,0,"env.");
			o << ";" << endl;
		}
	}
	o << ind(indt) << "esac" << endl;
}

void PlanProg2TLV::outputPlanningProgramRequirement(const PlanningProgram* p, std::ostream& o, unsigned int indt){
	o << ind(indt) << "-- planning program requirements: last holds on next state only if so does the pending goal" << endl;
	o << ind(indt) << "(next(last) -> (" << endl;
	vector<Transition*> transitions = p->getTransitions();
	for (unsigned int i = 0; i < transitions.size(); i++){
		if (transitions[i] -> getGoal() != NULL){
			o << ind(indt+1) << "(next(env.planning_program_transition) = " << transitions[i]->getName() << " & " ;
			outputGDFormula(transitions[i] -> getGoal(),o,0,"env.");
			o << ")";
		}
		if (i+1 < transitions.size()){
			o << "|";
		}
		else{
			o << ")";
		}
		o << endl;
	}	
	o << ")" << endl;
}


void PlanProg2TLV::outputGDFormula(const GD* precondition, std::ostream& o,  unsigned int indt, string scope){
	if (precondition == NULL){
		o << "next(TRUE)";
		return;
	}
	if (precondition->getAtom() != NULL){
        Literal* atom = precondition->getAtom();
        o << ind(indt);
        if (atom->isNegated()) {
            o << "!";
        }
        o << "next(" << scope << atom -> getAtomicFormulaTerm() ->getPredicate()->getName() << ")";
		return;
	}
	vector<GD*> conjuncts = precondition -> getConjuncts();
	if (conjuncts.size() == 0){
		o << "next(TRUE)";
		return;
	}
	for (unsigned int i = 0; i < conjuncts.size(); i++){
		outputGDFormula(conjuncts[i], o, indt,scope);
		if (i < conjuncts.size() -1 ){
			o << " & ";
		}
	}
}


//void PlanProg2TLV::outputGDFormula(const GD* precondition, std::ostream& o,  unsigned int indt, string scope){
//	if (precondition == NULL){
//		o << "TRUE";
//		return;
//	}
//	if (precondition->getAtom() != NULL){
//		o << ind(indt) << "next(" << scope << precondition->getAtom()->getPredicate()->getName() << ")";
//		return;
//	}
//	vector<GD*> conjuncts = precondition -> getConjuncts();
//	if (conjuncts.size() == 0){
//		o << "TRUE";
//		return;
//	}
//	for (unsigned int i = 0; i < conjuncts.size(); i++){
//		outputGDFormula(conjuncts[i], o, indt,scope);
//		if (i < conjuncts.size() -1 ){
//			o << " & ";
//		}
//	}
//}


void PlanProg2TLV::outputFluents(const Domain* d, std::ostream& o, unsigned int indt){
	vector<const Predicate*> predicates = d->getPredicates();
	for (unsigned int i = 0; i < predicates.size(); i++){
		o << ind(indt) << predicates[i]->getName() << " : boolean;";
		o << endl;
	}
}


void PlanProg2TLV::outputPlanningProgramNodes(const pprog::PlanningProgram* p, std::ostream& o, unsigned int indt){
	set<const Node*> nodes = p -> getNodes();
	set<const Node*>::iterator it = nodes.begin();
	while(it != nodes.end()){
		o << ind(indt) << (*it)->getName();
		it++;
		if (it != nodes.end()){
			o << ",";
		}
		o  << endl;
	}
}


void PlanProg2TLV::outputPlanningProgramTransitions(const pprog::PlanningProgram* p, std::ostream& o, unsigned int indt){
	vector<Transition*> transitions = p -> getTransitions();
	for(unsigned int i = 0; i < transitions.size(); i++){
		o << ind(indt) << transitions[i]->getName();
		if (i < transitions.size()-1){
			o << ",";
		}
		o  << endl;
	}
}


void PlanProg2TLV::outputEnvironmentInit(const Domain* d, const PlanningProgram* p, ostream& o, unsigned int indt){
	vector<const Predicate*> predicates = d->getPredicates();
	o << ind(indt) << "-- all predicates initially set to false, they are correctly initialized by start_action" << endl;
	for (unsigned int i = 0; i < predicates.size(); i++){
		o << ind(indt+1) << "!" << predicates[i]->getName();
		o << " & " << endl;
	}
	o << ind(indt) << "-- planning program in dummy initial state and transition" << endl;
	o << ind(indt+1) << "planning_program_state = start_state &" << endl;
	o << ind(indt+1) << "planning_program_transition = start_transition";
}


void PlanProg2TLV::outputEnvironmentActions(const ast::Domain* d, const pprog::PlanningProgram* p, std::ostream& o, unsigned int indt){
	map<const Predicate*,set<const Action*> > dependencies = predicateDependencies(d);
	vector<const Predicate*> predicates = d->getPredicates();
	vector<InitElement*> inits = p->getInitState();
	
	for (unsigned int i = 0; i < predicates.size(); i++){
		o << ind(indt) << "-- block for fluent " << predicates[i]->getName() << endl;
		o << ind(indt) << "case" << endl;
		
		// constraints for current predicate if affected by init
		set<const InitElement*> initAffect = affectedBy(inits, predicates[i]);
		if (!initAffect.empty()){
			o << ind(indt+1) << "sys.action = start_action : ";
			for (set<const InitElement*>::iterator it = initAffect.begin(); it != initAffect.end(); it++){
				if (it != initAffect.begin()){
					o << " & ";
				}
				if ((*it)->getLiteral()->isNegated()){
					o << "!";
				}
				o << "next (" << predicates[i]->getName() << ")";
			}		
			o << ";" << endl;
		}
		
		// constraints for current predicate depending on actions
		set<const Action*> affectingActions = dependencies[predicates[i]];
		for (set<const Action*>::iterator it = affectingActions.begin(); it != affectingActions.end(); it++){
			o << ind(indt+1) << "sys.action = " << (*it) -> getName() << " : ";
			set<const Literal*> affectingLiterals = (*it) -> affectingLiterals(predicates[i]);
			for (set<const Literal*>::iterator it2 = affectingLiterals.begin(); it2 != affectingLiterals.end(); it2++){
				if (it2 != affectingLiterals.begin()){
					o << " & ";
				}
				if ((*it2) -> isNegated()){
					o << "!";
				}
				o << "next(" << predicates[i]->getName() << ")";			
			}
			o << ";" << endl;
		}
		
		
		o << ind(indt+1) << "TRUE : next(" << predicates[i]->getName() << ") = " << predicates[i]->getName() << ";" << endl;		
		o << ind(indt) << "esac" << endl;

		if (i < predicates.size()-1){
			o << ind(indt) << "&";
		}		
	}
	
}



std::string PlanProg2TLV::ind(unsigned int i){
	string ind;
	for (unsigned int j = 1; j <= i; j++){
		ind += "  ";
	}	
	return ind;
}



map<const Predicate*,set<const Action*> > PlanProg2TLV::predicateDependencies(const ast::Domain* d){
	map<const Predicate*,set<const Action*> > dependencies;
	
	vector<const Action*> actions = d->getActions();
	for (unsigned int i = 0; i< actions.size(); i++){
		set<const Predicate*> affectedPredicates = actions[i]->affectedPredicates();
		for (set<const Predicate*>::iterator it = affectedPredicates.begin(); it != affectedPredicates.end(); it++){
			dependencies[*it].insert(actions[i]);
		}
	}	
	return dependencies;
}


set<const ast::InitElement*> PlanProg2TLV::affectedBy(vector<InitElement*> inits, const ast::Predicate* pred){
	set<const InitElement*> result;
	for (unsigned int i = 0; i < inits.size(); i++){
		if (inits[i]->getLiteral() != NULL){
			if (inits[i]->getLiteral()->getAtomicFormulaTerm() != NULL){
				if (inits[i]->getLiteral()->getAtomicFormulaTerm()->getPredicate() == pred){
					result.insert(inits[i]);
				}			
			}			
		}
	}
	return result;
}



void PlanProg2TLV::outputPlanningProgramConstraints(const ast::Domain* d, const pprog::PlanningProgram* p, std::ostream& o, unsigned int indt){
	o << ind(indt) << "-- constraints for planning program" << endl;
	o << ind(indt) << "case" << endl;
	o << ind(indt) << "--constraints depending on actions" << endl;
	o << ind(indt+1) << "sys.action = start_action : next(planning_program_state) = " << p->getInitNode()->getName() << ";" << endl;
	o << ind(indt) << "esac" << endl;
	o << ind(indt) << "&" << endl;		
	o << ind(indt) << "case" << endl;
	o << ind(indt) << "--invariant constraints " << endl;
	set<const Node*> nodes = p->getNodes();
	for (set<const Node*>::iterator it = nodes.begin(); it != nodes.end(); it++){
		vector<Transition*> outTransitions = (*it) -> getOutgoingTransitions();
		if(outTransitions.size() > 0){ 
			o << ind(indt+1) << "next(planning_program_state) = " << (*it) -> getName() << " : ";
			for (unsigned int i = 0; i < outTransitions.size(); i++){
				o << "next(planning_program_transition) = " << outTransitions[i] -> getName();
				if (i < outTransitions.size()-1){
					o << " | ";
				}
			}
			o << ";" << endl;
		}
	}
	o << ind(indt) << "esac" << endl;
	o << ind(indt) << "&" << endl;	
	o << ind(indt) << "case" << endl;
	o << ind(indt) << "--constraints depending on last" << endl;
	vector<Transition*> transitions = p->getTransitions();
	for (unsigned int i = 0; i < transitions.size(); i++){
		o << ind(indt+1) << "planning_program_transition = " << transitions[i] -> getName() << " & sys.last : next(planning_program_state) = " 
			<< transitions[i] -> getTo() -> getName() << ";" << endl;
		o << ind(indt+1) << "planning_program_transition = " << transitions[i] -> getName() << " & !sys.last : next(planning_program_state) = planning_program_state & " 
			<< "next(planning_program_transition) = "  << transitions[i] -> getName() << ";" << endl;
	}
	o << ind(indt) << "esac" << endl;
}




