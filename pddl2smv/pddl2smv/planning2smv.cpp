#include "planning2smv.h"

using namespace std;
using namespace ast;


ostream& Planning2SMV::toSMV(ostream& o, const Domain* d, const ast::Problem* p){
	
	outputHeader(o);
	o << endl; 
	outputMain(o);
	o << endl; 
	o << "LTLSPEC" << endl;
	outputGoal(p->getGoal(),o);
	o << endl << endl; 
	outputSystem(d,o);
	o << endl; 
	outputEnvironment(d,p,o);
	o << endl; 
	return o;
}


void Planning2SMV::outputHeader(ostream& o){
	o << "-- Automatically generated by planning2smv" << endl;
}


void Planning2SMV::outputMain(std::ostream& o){
	o << "MODULE main" << endl;	
	o << ind() << "VAR" << endl;
	o << ind(2) << "environment : environment_module(agent);" << endl;
	o << ind(2) << "agent : system_module(environment);" << endl;
	o << "-- end of main " << endl;
}

void Planning2SMV::outputSystem(const Domain* d, std::ostream& o){
	o << "MODULE system_module(env)" << endl << endl;	
	o << ind() << "VAR" << endl;	
	o << ind(2) << "action : {" << endl;
	o << ind(3) << "start_action," << endl;
	outputActionList(d,o, 3);
	o << ind(2) << "};" << endl << endl;
	
	o << ind() << "INIT" << endl;	
	o << ind(2) << "action = start_action" << endl << endl;	
	
	/*
	o << ind() << "TRANS" << endl;
	o << ind(2) << "next(action) != start_action &" << endl;
	o << ind(2) << "-- Action preconditions" << endl;	
	outputPreconditions(d,o,3);
	o << "-- end of system_module" << endl;
	*/
	
	o << ind() << "TRANS" << endl;
	o << ind(2) << "next(action) != start_action" << endl;
	
	o << ind() << "INVAR" << endl;
	o << ind(2) << "-- Action preconditions" << endl;	
	outputPreconditions(d,o,3);
	o << "-- end of system_module" << endl;

	
}


void Planning2SMV::outputEnvironment(const Domain* d, const ast::Problem* p, std::ostream& o){
	o << "MODULE environment_module(sys)" << endl << endl;
	o << ind() << "VAR" << endl;
	o << ind(2) << "--domain fluents" << endl;
	outputFluents(d,o,3);
	o << endl;
	o << ind() << "INIT" << endl;
	outputEnvironmentInit(d,o,2);
	o << endl;
	o << ind() << "TRANS" << endl;
	outputEnvironmentActions(d,p,o,2);
	o << "-- end of environment_module" << endl;
}


void Planning2SMV::outputActionList(const Domain* d, std::ostream& o, unsigned int indt){
	vector<const Action*> actions = d->getActions();
	for (unsigned int i = 0; i < actions.size(); i++){
		o << ind(indt) << actions[i]->getName();
		if (i < actions.size() - 1){
			o << ",";
		}
		o << endl;
	}
}

void Planning2SMV::outputPreconditions(const Domain* d, std::ostream& o, unsigned int indt){
	vector<const Action*> actions = d->getActions();
	o << ind(indt) << "case" << endl;
	for (unsigned int i = 0; i < actions.size(); i++){
		if (actions[i] -> getPrecondition() != NULL){
			/*
			o << ind(indt+1) << "next(action = " << actions[i]->getName() << ") : next(" ; 
			outputGDFormula(actions[i] -> getPrecondition(),o,0,"env.");
			o << ");" << endl;
			*/
			o << ind(indt+1) << "(action = " << actions[i]->getName() << ") : (" ; 
			outputGDFormula(actions[i] -> getPrecondition(),o,0,"env.");
			o << ");" << endl;
		}
	}
	o << ind(indt+1) << "(action = start_action) : TRUE;" << endl;
	o << ind(indt) << "esac" << endl;
}

void Planning2SMV::outputGDFormula(const GD* precondition, std::ostream& o,  unsigned int indt, string scope){
	if (precondition == NULL){
		o << "TRUE";
		return;
	}
	if (precondition->getAtom() != NULL){
		o << ind(indt) <<  scope << precondition->getAtom()->getPredicate()->getName();
		return;
	}
	vector<GD*> conjuncts = precondition -> getConjuncts();
	if (conjuncts.size() == 0){
		o << "TRUE";
		return;
	}
	for (unsigned int i = 0; i < conjuncts.size(); i++){
		outputGDFormula(conjuncts[i], o, indt,scope);
		if (i < conjuncts.size() -1 ){
			o << " & ";
		}
	}
}


void Planning2SMV::outputFluents(const Domain* d, std::ostream& o, unsigned int indt){
	vector<const Predicate*> predicates = d->getPredicates();
	for (unsigned int i = 0; i < predicates.size(); i++){
		o << ind(indt) << predicates[i]->getName() << " : boolean;";
		o << endl;
	}
}


void Planning2SMV::outputEnvironmentInit(const Domain* d, ostream& o, unsigned int indt){
	vector<const Predicate*> predicates = d->getPredicates();
	o << ind(indt) << "-- all predicates initially set to false, they'll be correctly initialized by start_action" << endl;
	for (unsigned int i = 0; i < predicates.size(); i++){
		o << ind(indt+1) << "!" << predicates[i]->getName();
		if (i < predicates.size() -1){
			o << " & " << endl;
		}
	}
}


void Planning2SMV::outputEnvironmentActions(const ast::Domain* d, const ast::Problem* p, std::ostream& o, unsigned int indt){
	map<const Predicate*,set<const Action*> > dependencies = predicateDependencies(d);
	vector<const Predicate*> predicates = d->getPredicates();
	vector<InitElement*> inits = p->getInit();
	
	for (unsigned int i = 0; i < predicates.size(); i++){
		o << ind(indt) << "-- block for fluent " << predicates[i]->getName() << endl;
		o << ind(indt) << "case" << endl;
		
		// constraints for current predicate if affected by init
		set<const InitElement*> initAffect = affectedBy(inits, predicates[i]);
		if (!initAffect.empty()){
			o << ind(indt+1) << "sys.action = start_action : ";
			for (set<const InitElement*>::iterator it = initAffect.begin(); it != initAffect.end(); it++){
				if (it != initAffect.begin()){
					o << " & ";
				}
				if ((*it)->getLiteral()->isNegated()){
					o << "!";
				}
				o << "next (" << predicates[i]->getName() << ")";
			}		
			o << ";" << endl;
		}
		
		// constraints for current predicate depending on actions
		set<const Action*> affectingActions = dependencies[predicates[i]];
		for (set<const Action*>::iterator it = affectingActions.begin(); it != affectingActions.end(); it++){
			o << ind(indt+1) << "sys.action = " << (*it) -> getName() << " : ";
			set<const Literal*> affectingLiterals = (*it) -> affectingLiterals(predicates[i]);
			for (set<const Literal*>::iterator it2 = affectingLiterals.begin(); it2 != affectingLiterals.end(); it2++){
				if (it2 != affectingLiterals.begin()){
					o << " & ";
				}
				if ((*it2) -> isNegated()){
					o << "!";
				}
				o << "next(" << predicates[i]->getName() << ")";			
			}
			o << ";" << endl;
		}
		
		
		o << ind(indt+1) << "TRUE : next(" << predicates[i]->getName() << ") = " << predicates[i]->getName() << ";" << endl;		
		o << ind(indt) << "esac" << endl;

		if (i < predicates.size()-1){
			o << ind(indt) << "&";
		}		
	}
	
}



std::string Planning2SMV::ind(unsigned int i){
	string ind;
	for (unsigned int j = 1; j <= i; j++){
		ind += "  ";
	}	
	return ind;
}



map<const Predicate*,set<const Action*> > Planning2SMV::predicateDependencies(const ast::Domain* d){
	map<const Predicate*,set<const Action*> > dependencies;
	
	vector<const Action*> actions = d->getActions();
	for (unsigned int i = 0; i< actions.size(); i++){
		set<const Predicate*> affectedPredicates = actions[i]->affectedPredicates();
		for (set<const Predicate*>::iterator it = affectedPredicates.begin(); it != affectedPredicates.end(); it++){
			dependencies[*it].insert(actions[i]);
		}
	}	
	return dependencies;
}


set<const ast::InitElement*> Planning2SMV::affectedBy(vector<InitElement*> inits, const ast::Predicate* pred){
	set<const InitElement*> result;
	for (unsigned int i = 0; i < inits.size(); i++){
		if (inits[i]->getLiteral() != NULL){
			if (inits[i]->getLiteral()->getAtomicFormulaTerm() != NULL){
				if (inits[i]->getLiteral()->getAtomicFormulaTerm()->getPredicate() == pred){
					result.insert(inits[i]);
				}			
			}			
		}
	}
	return result;
}

void Planning2SMV::outputGoal(const ast::LTLNode* g, std::ostream& o){
	switch (g->op){
		case (NN):
			if (g->atom != NULL){
				o << "environment." << g->atom->getPredicate()->getName();
			}
			break;
		case (NEXT):
			if (g->left != NULL){
				o << "X(";
				outputGoal(g->left,o);
				o << ")";
			}
			break;
		case (RELEASE):
			if (g->left != NULL && g->right != NULL){
				o << "(";
				outputGoal(g->left,o);
				o<< ") V (";
				outputGoal(g->right,o);
				o<< ")";
			}
			break;
		case (UNTIL):
			if (g->left != NULL && g->right != NULL){
				o << "(";
				outputGoal(g->left,o);
				o<< ") U (";
				outputGoal(g->right,o);
				o<< ")";
			}
			break;
		case (ALW):
			if (g->left != NULL){
				o << "G(";
				outputGoal(g->left,o);
				o << ")";
			}
			break;
		case (EVT):
			if (g->left != NULL){
				o << "F(";
				outputGoal(g->left,o);
				o << ")";
			}
			break;
		case (IFF):
			if (g->left != NULL && g->right != NULL){
				o << "(";
				outputGoal(g->left,o);
				o<< ") <-> (";
				outputGoal(g->right,o);
				o<< ")";
			}
			break;
		case (IMPL):
			if (g->left != NULL && g->right != NULL){
				o << "(";
				outputGoal(g->left,o);
				o<< ") -> (";
				outputGoal(g->right,o);
				o<< ")";
			}
			break;
		case (NOT):
			if (g->left != NULL){
				o << "!(";
				outputGoal(g->left,o);
				o << ")";
			}
			break;
		case (AND):
			if (g->left != NULL && g->right != NULL){
				o << "(";
				outputGoal(g->left,o);
				o<< ") & (";
				outputGoal(g->right,o);
				o<< ")";
			}
			break;
		case (OR):
			if (g->left != NULL && g->right != NULL){
				o << "(";
				outputGoal(g->left,o);
				o<< ") | (";
				outputGoal(g->right,o);
				o<< ")";
			}
			break;
		default: 
			break;
	}
}

