-- Automatically generated by pp2smv

MODULE system_module(env)

  VAR
    action : {
      start_action,
      pickup_b1,
      pickup_b2,
      putdown_b1,
      putdown_b2,
      stack_b1_b1,
      stack_b1_b2,
      stack_b2_b1,
      stack_b2_b2,
      unstack_b1_b1,
      unstack_b1_b2,
      unstack_b2_b1,
      unstack_b2_b2,
      nop
    };

    last : boolean;

  INIT
    action = start_action & last = FALSE

  TRANS
    next(action) != start_action &
    (next(action) = nop <-> next(last)) &
    -- Action preconditions
    case
      next(action) = pickup_b1 : next(env.clear_b1) & next(env.on-table_b1) & next(env.arm-empty);
      next(action) = pickup_b2 : next(env.clear_b2) & next(env.on-table_b2) & next(env.arm-empty);
      next(action) = putdown_b1 : next(env.holding_b1);
      next(action) = putdown_b2 : next(env.holding_b2);
      next(action) = stack_b1_b1 : next(env.clear_b1) & next(env.holding_b1);
      next(action) = stack_b1_b2 : next(env.clear_b2) & next(env.holding_b1);
      next(action) = stack_b2_b1 : next(env.clear_b1) & next(env.holding_b2);
      next(action) = stack_b2_b2 : next(env.clear_b2) & next(env.holding_b2);
      next(action) = unstack_b1_b1 : next(env.on_b1_b1) & next(env.clear_b1) & next(env.arm-empty);
      next(action) = unstack_b1_b2 : next(env.on_b1_b2) & next(env.clear_b1) & next(env.arm-empty);
      next(action) = unstack_b2_b1 : next(env.on_b2_b1) & next(env.clear_b2) & next(env.arm-empty);
      next(action) = unstack_b2_b2 : next(env.on_b2_b2) & next(env.clear_b2) & next(env.arm-empty);
      TRUE : TRUE;
    esac
    &
    -- planning program requirements: last holds on next state only if so does the pending goal
    (next(last) -> (
      (next(env.planning_program_transition) = trans_2 & next(env.on_b1_b2))|
      (next(env.planning_program_transition) = trans_3 & next(env.ftrue)))
)
-- end of system_module

MODULE environment_module(sys)

  VAR
    --domain fluents
      clear_b1 : boolean;
      clear_b2 : boolean;
      on-table_b1 : boolean;
      on-table_b2 : boolean;
      arm-empty : boolean;
      holding_b1 : boolean;
      holding_b2 : boolean;
      on_b1_b1 : boolean;
      on_b1_b2 : boolean;
      on_b2_b1 : boolean;
      on_b2_b2 : boolean;
      ftrue : boolean;

    --planning program current state
      planning_program_state : {
        start_state,
        n2,
        n1
      };

    --pending planning program transition
      planning_program_transition : {
        start_transition,
        trans_2,
        trans_3
      };

  INIT
    -- all predicates initially set to false, they are correctly initialized by start_action
      !clear_b1 & 
      !clear_b2 & 
      !on-table_b1 & 
      !on-table_b2 & 
      !arm-empty & 
      !holding_b1 & 
      !holding_b2 & 
      !on_b1_b1 & 
      !on_b1_b2 & 
      !on_b2_b1 & 
      !on_b2_b2 & 
      !ftrue & 
    -- planning program in dummy initial state and transition
      planning_program_state = start_state &
      planning_program_transition = start_transition
  TRANS
    -- block for fluent clear_b1
    case
      sys.action = start_action : next (clear_b1);
      sys.action = pickup_b1 : !next(clear_b1);
      sys.action = putdown_b1 : next(clear_b1);
      sys.action = stack_b1_b1 : next(clear_b1) & !next(clear_b1);
      sys.action = stack_b1_b2 : next(clear_b1);
      sys.action = stack_b2_b1 : !next(clear_b1);
      sys.action = unstack_b1_b1 : next(clear_b1) & !next(clear_b1);
      sys.action = unstack_b1_b2 : !next(clear_b1);
      sys.action = unstack_b2_b1 : next(clear_b1);
      TRUE : next(clear_b1) = clear_b1;
    esac
    &    -- block for fluent clear_b2
    case
      sys.action = start_action : next (clear_b2);
      sys.action = pickup_b2 : !next(clear_b2);
      sys.action = putdown_b2 : next(clear_b2);
      sys.action = stack_b1_b2 : !next(clear_b2);
      sys.action = stack_b2_b1 : next(clear_b2);
      sys.action = stack_b2_b2 : next(clear_b2) & !next(clear_b2);
      sys.action = unstack_b1_b2 : next(clear_b2);
      sys.action = unstack_b2_b1 : !next(clear_b2);
      sys.action = unstack_b2_b2 : next(clear_b2) & !next(clear_b2);
      TRUE : next(clear_b2) = clear_b2;
    esac
    &    -- block for fluent on-table_b1
    case
      sys.action = start_action : next (on-table_b1);
      sys.action = pickup_b1 : !next(on-table_b1);
      sys.action = putdown_b1 : next(on-table_b1);
      TRUE : next(on-table_b1) = on-table_b1;
    esac
    &    -- block for fluent on-table_b2
    case
      sys.action = start_action : next (on-table_b2);
      sys.action = pickup_b2 : !next(on-table_b2);
      sys.action = putdown_b2 : next(on-table_b2);
      TRUE : next(on-table_b2) = on-table_b2;
    esac
    &    -- block for fluent arm-empty
    case
      sys.action = start_action : next (arm-empty);
      sys.action = pickup_b1 : !next(arm-empty);
      sys.action = pickup_b2 : !next(arm-empty);
      sys.action = putdown_b1 : next(arm-empty);
      sys.action = putdown_b2 : next(arm-empty);
      sys.action = stack_b1_b1 : next(arm-empty);
      sys.action = stack_b1_b2 : next(arm-empty);
      sys.action = stack_b2_b1 : next(arm-empty);
      sys.action = stack_b2_b2 : next(arm-empty);
      sys.action = unstack_b1_b1 : !next(arm-empty);
      sys.action = unstack_b1_b2 : !next(arm-empty);
      sys.action = unstack_b2_b1 : !next(arm-empty);
      sys.action = unstack_b2_b2 : !next(arm-empty);
      TRUE : next(arm-empty) = arm-empty;
    esac
    &    -- block for fluent holding_b1
    case
      sys.action = pickup_b1 : next(holding_b1);
      sys.action = putdown_b1 : !next(holding_b1);
      sys.action = stack_b1_b1 : !next(holding_b1);
      sys.action = stack_b1_b2 : !next(holding_b1);
      sys.action = unstack_b1_b1 : next(holding_b1);
      sys.action = unstack_b1_b2 : next(holding_b1);
      TRUE : next(holding_b1) = holding_b1;
    esac
    &    -- block for fluent holding_b2
    case
      sys.action = pickup_b2 : next(holding_b2);
      sys.action = putdown_b2 : !next(holding_b2);
      sys.action = stack_b2_b1 : !next(holding_b2);
      sys.action = stack_b2_b2 : !next(holding_b2);
      sys.action = unstack_b2_b1 : next(holding_b2);
      sys.action = unstack_b2_b2 : next(holding_b2);
      TRUE : next(holding_b2) = holding_b2;
    esac
    &    -- block for fluent on_b1_b1
    case
      sys.action = stack_b1_b1 : next(on_b1_b1);
      sys.action = unstack_b1_b1 : !next(on_b1_b1);
      TRUE : next(on_b1_b1) = on_b1_b1;
    esac
    &    -- block for fluent on_b1_b2
    case
      sys.action = stack_b1_b2 : next(on_b1_b2);
      sys.action = unstack_b1_b2 : !next(on_b1_b2);
      TRUE : next(on_b1_b2) = on_b1_b2;
    esac
    &    -- block for fluent on_b2_b1
    case
      sys.action = stack_b2_b1 : next(on_b2_b1);
      sys.action = unstack_b2_b1 : !next(on_b2_b1);
      TRUE : next(on_b2_b1) = on_b2_b1;
    esac
    &    -- block for fluent on_b2_b2
    case
      sys.action = stack_b2_b2 : next(on_b2_b2);
      sys.action = unstack_b2_b2 : !next(on_b2_b2);
      TRUE : next(on_b2_b2) = on_b2_b2;
    esac
    &    -- block for fluent ftrue
    case
      sys.action = start_action : next (ftrue);
      TRUE : next(ftrue) = ftrue;
    esac
    &
    -- constraints for planning program
    case
    --constraints depending on actions
      sys.action = start_action : next(planning_program_state) = n1;
      TRUE : TRUE;
    esac
    &
    case
    --invariant constraints 
      next(planning_program_state) = n2 : next(planning_program_transition) = trans_3;
      next(planning_program_state) = n1 : next(planning_program_transition) = trans_2;
      TRUE : TRUE;
    esac
    &
    case
    --constraints depending on last
      planning_program_transition = trans_2 & sys.last : next(planning_program_state) = n2;
      planning_program_transition = trans_2 & !sys.last : next(planning_program_state) = planning_program_state & next(planning_program_transition) = trans_2;
      planning_program_transition = trans_3 & sys.last : next(planning_program_state) = n2;
      planning_program_transition = trans_3 & !sys.last : next(planning_program_state) = planning_program_state & next(planning_program_transition) = trans_3;
      TRUE : TRUE;
    esac
-- end of environment_module

GAME
--- NON-DETERMINISTIC ENVIRONMENT PLAYER
PLAYER_1
  VAR
    dom : environment_module(agent);
--- CONTROLLER PLAYER ENVIRONMENT
PLAYER_2
  VAR
    agent : system_module(dom);


BUCHIGAME PLAYER_2 (agent.last)
-- end of NuGAT planning program encoding

