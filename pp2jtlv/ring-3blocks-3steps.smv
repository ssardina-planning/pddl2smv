-- Automatically generated by pp2smv

MODULE main
  VAR
    environment : system environment_module(agent);
    agent : system system_module(environment);
  DEFINE
    good := agent.last;
-- end of main 

MODULE system_module(env)

  VAR
    action : {
      start_action,
      pickup_b1,
      pickup_b3,
      pickup_b2,
      putdown_b1,
      putdown_b3,
      putdown_b2,
      stack_b1_b1,
      stack_b1_b3,
      stack_b1_b2,
      stack_b3_b1,
      stack_b3_b3,
      stack_b3_b2,
      stack_b2_b1,
      stack_b2_b3,
      stack_b2_b2,
      unstack_b1_b1,
      unstack_b1_b3,
      unstack_b1_b2,
      unstack_b3_b1,
      unstack_b3_b3,
      unstack_b3_b2,
      unstack_b2_b1,
      unstack_b2_b3,
      unstack_b2_b2,
      nop
    };

    last : boolean;

  INIT
    action = start_action & last = 0

  TRANS
    next(action) != start_action &
    (next(action) = nop <-> next(last)) &
    -- Action preconditions
    case
      next(action) = pickup_b1 : next(env.clear_b1) & next(env.on-table_b1) & next(env.arm-empty);
      next(action) = pickup_b3 : next(env.clear_b3) & next(env.on-table_b3) & next(env.arm-empty);
      next(action) = pickup_b2 : next(env.clear_b2) & next(env.on-table_b2) & next(env.arm-empty);
      next(action) = putdown_b1 : next(env.holding_b1);
      next(action) = putdown_b3 : next(env.holding_b3);
      next(action) = putdown_b2 : next(env.holding_b2);
      next(action) = stack_b1_b1 : next(env.clear_b1) & next(env.holding_b1);
      next(action) = stack_b1_b3 : next(env.clear_b3) & next(env.holding_b1);
      next(action) = stack_b1_b2 : next(env.clear_b2) & next(env.holding_b1);
      next(action) = stack_b3_b1 : next(env.clear_b1) & next(env.holding_b3);
      next(action) = stack_b3_b3 : next(env.clear_b3) & next(env.holding_b3);
      next(action) = stack_b3_b2 : next(env.clear_b2) & next(env.holding_b3);
      next(action) = stack_b2_b1 : next(env.clear_b1) & next(env.holding_b2);
      next(action) = stack_b2_b3 : next(env.clear_b3) & next(env.holding_b2);
      next(action) = stack_b2_b2 : next(env.clear_b2) & next(env.holding_b2);
      next(action) = unstack_b1_b1 : next(env.on_b1_b1) & next(env.clear_b1) & next(env.arm-empty);
      next(action) = unstack_b1_b3 : next(env.on_b1_b3) & next(env.clear_b1) & next(env.arm-empty);
      next(action) = unstack_b1_b2 : next(env.on_b1_b2) & next(env.clear_b1) & next(env.arm-empty);
      next(action) = unstack_b3_b1 : next(env.on_b3_b1) & next(env.clear_b3) & next(env.arm-empty);
      next(action) = unstack_b3_b3 : next(env.on_b3_b3) & next(env.clear_b3) & next(env.arm-empty);
      next(action) = unstack_b3_b2 : next(env.on_b3_b2) & next(env.clear_b3) & next(env.arm-empty);
      next(action) = unstack_b2_b1 : next(env.on_b2_b1) & next(env.clear_b2) & next(env.arm-empty);
      next(action) = unstack_b2_b3 : next(env.on_b2_b3) & next(env.clear_b2) & next(env.arm-empty);
      next(action) = unstack_b2_b2 : next(env.on_b2_b2) & next(env.clear_b2) & next(env.arm-empty);
    esac
    &
    -- planning program requirements: last holds on next state only if so does the pending goal
    (next(last) -> (
      (next(env.planning_program_transition) = trans_3 & next(env.on_b1_b2))|
      (next(env.planning_program_transition) = trans_4 & next(env.on_b2_b1))|
      (next(env.planning_program_transition) = trans_5 & next(env.on_b3_b2) & next(env.on_b2_b1)))
)
-- end of system_module

MODULE environment_module(sys)

  VAR
    --domain fluents
      clear_b1 : boolean;
      clear_b3 : boolean;
      clear_b2 : boolean;
      on-table_b1 : boolean;
      on-table_b3 : boolean;
      on-table_b2 : boolean;
      arm-empty : boolean;
      holding_b1 : boolean;
      holding_b3 : boolean;
      holding_b2 : boolean;
      on_b1_b1 : boolean;
      on_b1_b3 : boolean;
      on_b1_b2 : boolean;
      on_b3_b1 : boolean;
      on_b3_b3 : boolean;
      on_b3_b2 : boolean;
      on_b2_b1 : boolean;
      on_b2_b3 : boolean;
      on_b2_b2 : boolean;

    --planning program current state
      planning_program_state : {
        start_state,
        n2,
        n1,
        n0
      };

    --pending planning program transition
      planning_program_transition : {
        start_transition,
        trans_3,
        trans_4,
        trans_5
      };

  INIT
    -- all predicates initially set to false, they are correctly initialized by start_action
      !clear_b1 & 
      !clear_b3 & 
      !clear_b2 & 
      !on-table_b1 & 
      !on-table_b3 & 
      !on-table_b2 & 
      !arm-empty & 
      !holding_b1 & 
      !holding_b3 & 
      !holding_b2 & 
      !on_b1_b1 & 
      !on_b1_b3 & 
      !on_b1_b2 & 
      !on_b3_b1 & 
      !on_b3_b3 & 
      !on_b3_b2 & 
      !on_b2_b1 & 
      !on_b2_b3 & 
      !on_b2_b2 & 
    -- planning program in dummy initial state and transition
      planning_program_state = start_state &
      planning_program_transition = start_transition
  TRANS
    -- block for fluent clear_b1
    case
      sys.action = start_action : next (clear_b1);
      sys.action = pickup_b1 : !next(clear_b1);
      sys.action = putdown_b1 : next(clear_b1);
      sys.action = unstack_b1_b1 : next(clear_b1) & !next(clear_b1);
      sys.action = stack_b1_b1 : next(clear_b1) & !next(clear_b1);
      sys.action = stack_b3_b1 : !next(clear_b1);
      sys.action = unstack_b2_b1 : next(clear_b1);
      sys.action = stack_b1_b3 : next(clear_b1);
      sys.action = stack_b1_b2 : next(clear_b1);
      sys.action = stack_b2_b1 : !next(clear_b1);
      sys.action = unstack_b1_b3 : !next(clear_b1);
      sys.action = unstack_b3_b1 : next(clear_b1);
      sys.action = unstack_b1_b2 : !next(clear_b1);
      TRUE : next(clear_b1) = clear_b1;
    esac
    &    -- block for fluent clear_b3
    case
      sys.action = start_action : next (clear_b3);
      sys.action = pickup_b3 : !next(clear_b3);
      sys.action = putdown_b3 : next(clear_b3);
      sys.action = stack_b3_b3 : next(clear_b3) & !next(clear_b3);
      sys.action = stack_b3_b1 : next(clear_b3);
      sys.action = stack_b1_b3 : !next(clear_b3);
      sys.action = stack_b3_b2 : next(clear_b3);
      sys.action = unstack_b1_b3 : next(clear_b3);
      sys.action = stack_b2_b3 : !next(clear_b3);
      sys.action = unstack_b3_b1 : !next(clear_b3);
      sys.action = unstack_b3_b2 : !next(clear_b3);
      sys.action = unstack_b3_b3 : next(clear_b3) & !next(clear_b3);
      sys.action = unstack_b2_b3 : next(clear_b3);
      TRUE : next(clear_b3) = clear_b3;
    esac
    &    -- block for fluent clear_b2
    case
      sys.action = start_action : next (clear_b2);
      sys.action = pickup_b2 : !next(clear_b2);
      sys.action = putdown_b2 : next(clear_b2);
      sys.action = unstack_b2_b1 : !next(clear_b2);
      sys.action = stack_b1_b2 : !next(clear_b2);
      sys.action = stack_b2_b1 : next(clear_b2);
      sys.action = stack_b3_b2 : !next(clear_b2);
      sys.action = stack_b2_b3 : next(clear_b2);
      sys.action = stack_b2_b2 : next(clear_b2) & !next(clear_b2);
      sys.action = unstack_b1_b2 : next(clear_b2);
      sys.action = unstack_b3_b2 : next(clear_b2);
      sys.action = unstack_b2_b2 : next(clear_b2) & !next(clear_b2);
      sys.action = unstack_b2_b3 : !next(clear_b2);
      TRUE : next(clear_b2) = clear_b2;
    esac
    &    -- block for fluent on-table_b1
    case
      sys.action = start_action : next (on-table_b1);
      sys.action = pickup_b1 : !next(on-table_b1);
      sys.action = putdown_b1 : next(on-table_b1);
      TRUE : next(on-table_b1) = on-table_b1;
    esac
    &    -- block for fluent on-table_b3
    case
      sys.action = start_action : next (on-table_b3);
      sys.action = pickup_b3 : !next(on-table_b3);
      sys.action = putdown_b3 : next(on-table_b3);
      TRUE : next(on-table_b3) = on-table_b3;
    esac
    &    -- block for fluent on-table_b2
    case
      sys.action = start_action : next (on-table_b2);
      sys.action = pickup_b2 : !next(on-table_b2);
      sys.action = putdown_b2 : next(on-table_b2);
      TRUE : next(on-table_b2) = on-table_b2;
    esac
    &    -- block for fluent arm-empty
    case
      sys.action = start_action : next (arm-empty);
      sys.action = pickup_b1 : !next(arm-empty);
      sys.action = pickup_b3 : !next(arm-empty);
      sys.action = pickup_b2 : !next(arm-empty);
      sys.action = putdown_b1 : next(arm-empty);
      sys.action = putdown_b3 : next(arm-empty);
      sys.action = putdown_b2 : next(arm-empty);
      sys.action = unstack_b1_b1 : !next(arm-empty);
      sys.action = stack_b1_b1 : next(arm-empty);
      sys.action = stack_b3_b3 : next(arm-empty);
      sys.action = stack_b3_b1 : next(arm-empty);
      sys.action = unstack_b2_b1 : !next(arm-empty);
      sys.action = stack_b1_b3 : next(arm-empty);
      sys.action = stack_b1_b2 : next(arm-empty);
      sys.action = stack_b2_b1 : next(arm-empty);
      sys.action = stack_b3_b2 : next(arm-empty);
      sys.action = unstack_b1_b3 : !next(arm-empty);
      sys.action = stack_b2_b3 : next(arm-empty);
      sys.action = stack_b2_b2 : next(arm-empty);
      sys.action = unstack_b3_b1 : !next(arm-empty);
      sys.action = unstack_b1_b2 : !next(arm-empty);
      sys.action = unstack_b3_b2 : !next(arm-empty);
      sys.action = unstack_b3_b3 : !next(arm-empty);
      sys.action = unstack_b2_b2 : !next(arm-empty);
      sys.action = unstack_b2_b3 : !next(arm-empty);
      TRUE : next(arm-empty) = arm-empty;
    esac
    &    -- block for fluent holding_b1
    case
      sys.action = pickup_b1 : next(holding_b1);
      sys.action = putdown_b1 : !next(holding_b1);
      sys.action = unstack_b1_b1 : next(holding_b1);
      sys.action = stack_b1_b1 : !next(holding_b1);
      sys.action = stack_b1_b3 : !next(holding_b1);
      sys.action = stack_b1_b2 : !next(holding_b1);
      sys.action = unstack_b1_b3 : next(holding_b1);
      sys.action = unstack_b1_b2 : next(holding_b1);
      TRUE : next(holding_b1) = holding_b1;
    esac
    &    -- block for fluent holding_b3
    case
      sys.action = pickup_b3 : next(holding_b3);
      sys.action = putdown_b3 : !next(holding_b3);
      sys.action = stack_b3_b3 : !next(holding_b3);
      sys.action = stack_b3_b1 : !next(holding_b3);
      sys.action = stack_b3_b2 : !next(holding_b3);
      sys.action = unstack_b3_b1 : next(holding_b3);
      sys.action = unstack_b3_b2 : next(holding_b3);
      sys.action = unstack_b3_b3 : next(holding_b3);
      TRUE : next(holding_b3) = holding_b3;
    esac
    &    -- block for fluent holding_b2
    case
      sys.action = pickup_b2 : next(holding_b2);
      sys.action = putdown_b2 : !next(holding_b2);
      sys.action = unstack_b2_b1 : next(holding_b2);
      sys.action = stack_b2_b1 : !next(holding_b2);
      sys.action = stack_b2_b3 : !next(holding_b2);
      sys.action = stack_b2_b2 : !next(holding_b2);
      sys.action = unstack_b2_b2 : next(holding_b2);
      sys.action = unstack_b2_b3 : next(holding_b2);
      TRUE : next(holding_b2) = holding_b2;
    esac
    &    -- block for fluent on_b1_b1
    case
      sys.action = unstack_b1_b1 : !next(on_b1_b1);
      sys.action = stack_b1_b1 : next(on_b1_b1);
      TRUE : next(on_b1_b1) = on_b1_b1;
    esac
    &    -- block for fluent on_b1_b3
    case
      sys.action = stack_b1_b3 : next(on_b1_b3);
      sys.action = unstack_b1_b3 : !next(on_b1_b3);
      TRUE : next(on_b1_b3) = on_b1_b3;
    esac
    &    -- block for fluent on_b1_b2
    case
      sys.action = stack_b1_b2 : next(on_b1_b2);
      sys.action = unstack_b1_b2 : !next(on_b1_b2);
      TRUE : next(on_b1_b2) = on_b1_b2;
    esac
    &    -- block for fluent on_b3_b1
    case
      sys.action = stack_b3_b1 : next(on_b3_b1);
      sys.action = unstack_b3_b1 : !next(on_b3_b1);
      TRUE : next(on_b3_b1) = on_b3_b1;
    esac
    &    -- block for fluent on_b3_b3
    case
      sys.action = stack_b3_b3 : next(on_b3_b3);
      sys.action = unstack_b3_b3 : !next(on_b3_b3);
      TRUE : next(on_b3_b3) = on_b3_b3;
    esac
    &    -- block for fluent on_b3_b2
    case
      sys.action = stack_b3_b2 : next(on_b3_b2);
      sys.action = unstack_b3_b2 : !next(on_b3_b2);
      TRUE : next(on_b3_b2) = on_b3_b2;
    esac
    &    -- block for fluent on_b2_b1
    case
      sys.action = unstack_b2_b1 : !next(on_b2_b1);
      sys.action = stack_b2_b1 : next(on_b2_b1);
      TRUE : next(on_b2_b1) = on_b2_b1;
    esac
    &    -- block for fluent on_b2_b3
    case
      sys.action = stack_b2_b3 : next(on_b2_b3);
      sys.action = unstack_b2_b3 : !next(on_b2_b3);
      TRUE : next(on_b2_b3) = on_b2_b3;
    esac
    &    -- block for fluent on_b2_b2
    case
      sys.action = stack_b2_b2 : next(on_b2_b2);
      sys.action = unstack_b2_b2 : !next(on_b2_b2);
      TRUE : next(on_b2_b2) = on_b2_b2;
    esac
    &
    -- constraints for planning program
    case
    --constraints depending on actions
      sys.action = start_action : next(planning_program_state) = n0;
    esac
    &
    case
    --invariant constraints 
      next(planning_program_state) = n2 : next(planning_program_transition) = trans_5;
      next(planning_program_state) = n1 : next(planning_program_transition) = trans_4;
      next(planning_program_state) = n0 : next(planning_program_transition) = trans_3;
    esac
    &
    case
    --constraints depending on last
      planning_program_transition = trans_3 & sys.last : next(planning_program_state) = n1;
      planning_program_transition = trans_3 & !sys.last : next(planning_program_state) = planning_program_state & next(planning_program_transition) = trans_3;
      planning_program_transition = trans_4 & sys.last : next(planning_program_state) = n2;
      planning_program_transition = trans_4 & !sys.last : next(planning_program_state) = planning_program_state & next(planning_program_transition) = trans_4;
      planning_program_transition = trans_5 & sys.last : next(planning_program_state) = n0;
      planning_program_transition = trans_5 & !sys.last : next(planning_program_state) = planning_program_state & next(planning_program_transition) = trans_5;
    esac
-- end of environment_module

