-- Automatically generated by pddl2smv
MODULE main
	VAR
		environment : system environment_module(agent);
		agent : system system_module(environment);
	DEFINE
		jx := agent.jx;
-- end main 

MODULE system_module(env)
	VAR
		action : {
				smv_start_action, pick-up_d, pick-up_c, pick-up_b, pick-up_a, 
				put-down_d, put-down_c, put-down_b, put-down_a, smv_stop_action};
		jx : 1..1;
	INIT
		action = smv_start_action
	TRANS
		-- Special actions:
		next(action) != smv_start_action &
		((next(action) = smv_stop_action) <-> 
			(next(env.holding_d) & next(env.ontable_a))
		)&
		-- Action preconditions
		case
			next(action) = pick-up_d : next(env.ontable_d);
			next(action) = pick-up_c : next(env.ontable_c);
			next(action) = pick-up_b : next(env.ontable_b);
			next(action) = pick-up_a : next(env.ontable_a);
			next(action) = put-down_d : next(env.holding_d);
			next(action) = put-down_c : next(env.holding_c);
			next(action) = put-down_b : next(env.holding_b);
			next(action) = put-down_a : next(env.holding_a);
			TRUE : TRUE; -- for special actions
		esac
		-- justice requirements: problem goal
		JUSTICE
			(env.holding_d & env.ontable_a)
-- end system_module

MODULE environment_module(ag)
	VAR
		-- domain fluents
			holding_a : boolean; 
			holding_b : boolean; 
			holding_c : boolean; 
			holding_d : boolean; 
			ontable_a : boolean; 
			ontable_b : boolean; 
			ontable_c : boolean; 
			ontable_d : boolean; 

	INIT
		-- all fluents are initially set to false. They will be correctly initialized at the first step by smv_start_action
			!holding_a & !holding_b & !holding_c & !holding_d & !ontable_a & 
			!ontable_b & !ontable_c & !ontable_d
			
	TRANS
	--transition relation based on fluents and actions plus stop action for goal achievement
		-- block for fluent holding_a
		case
			--direct effects
			ag.action = put-down_a : !next(holding_a);
			ag.action = smv_start_action : next(holding_a);
			ag.action = pick-up_a : next(holding_a);
			--default
			TRUE : next(holding_a) = holding_a;
		esac
		&
		-- block for fluent ontable_b
		case
			--direct effects
			ag.action = pick-up_b : !next(ontable_b);
			ag.action = smv_start_action : next(ontable_b);
			ag.action = put-down_b : next(ontable_b);
			--default
			TRUE : next(ontable_b) = ontable_b;
		esac
		&
		-- block for fluent ontable_c
		case
			--direct effects
			ag.action = pick-up_c : !next(ontable_c);
			ag.action = smv_start_action : next(ontable_c);
			ag.action = put-down_c : next(ontable_c);
			--default
			TRUE : next(ontable_c) = ontable_c;
		esac
		&
		-- block for fluent ontable_d
		case
			--direct effects
			ag.action = pick-up_d : !next(ontable_d);
			ag.action = smv_start_action : next(ontable_d);
			ag.action = put-down_d : next(ontable_d);
			--default
			TRUE : next(ontable_d) = ontable_d;
		esac
		&
		-- block for fluent holding_d
		case
			--direct effects
			ag.action = put-down_d : !next(holding_d);
			ag.action = pick-up_d : next(holding_d);
			--default
			TRUE : next(holding_d) = holding_d;
		esac
		&
		-- block for fluent holding_c
		case
			--direct effects
			ag.action = put-down_c : !next(holding_c);
			ag.action = pick-up_c : next(holding_c);
			--default
			TRUE : next(holding_c) = holding_c;
		esac
		&
		-- block for fluent holding_b
		case
			--direct effects
			ag.action = put-down_b : !next(holding_b);
			ag.action = pick-up_b : next(holding_b);
			--default
			TRUE : next(holding_b) = holding_b;
		esac
		&
		-- block for fluent ontable_a
		case
			--direct effects
			ag.action = pick-up_a : !next(ontable_a);
			ag.action = put-down_a : next(ontable_a);
			--default
			TRUE : next(ontable_a) = ontable_a;
		esac
	JUSTICE
		TRUE
-- end environment_module
